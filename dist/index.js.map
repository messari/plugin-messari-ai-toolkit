{"version":3,"sources":["../src/providers/messari/index.ts","../src/providers/messari/api.ts","../src/providers/messari/config.ts","../src/providers/messari/memory.ts","../src/providers/index.ts","../src/index.ts"],"sourcesContent":["import {\n  AgentRuntime,\n  ModelClass,\n  Provider,\n  elizaLogger,\n  generateText,\n  composeContext,\n} from \"@elizaos/core\";\nimport type { Memory, State } from \"@elizaos/core\";\nimport { callMessariAPI } from \"./api\";\nimport { DEFAULT_CONFIG, validateConfig } from \"./config\";\nimport { findRelevantMemory, getRecentMessages, storeMemory } from \"./memory\";\n\n// Template for question generation\nconst COPILOT_QUESTION_TEMPLATE = `IMPORTANT: Your primary task is to identify research questions in the CURRENT MESSAGE. Recent messages are provided only as supporting context.\n\nCurrent message to analyze: {{currentMessage}}\nSupporting context from recent messages (last ${DEFAULT_CONFIG.RECENT_MESSAGES_COUNT}): {{recentMessages}}\n\nFirst, focus on the current message and identify if it contains any research questions or requests. Only if the current message is ambiguous or references previous messages, consider the supporting context.\n\nConsider the following as research questions:\n1. Requests for market data, statistics, or metrics\n2. Questions about rankings or comparisons\n3. Requests for historical data or trends\n4. Questions about specific protocols, tokens, or platforms\n5. Requests for financial analysis or performance data\n\nExtract and output the exact research question from the CURRENT MESSAGE. If multiple questions exist in the current message, output the most relevant one.\nIf there are NO research questions in the current message, output \"NONE\".\n\nRemember:\n- Focus primarily on the current message\n- Any request for data, rankings, or market information should be considered a research question, even if not phrased as a question\n- Only use recent messages for context if the current message is ambiguous or references them directly\n\nExamples:\n- Current: \"what are the top 10 L2s by fees\" -> \"what are the top 10 L2s by fees\"\n- Current: \"show me ETH price\" -> \"what is the current price of ETH\"\n- Current: \"TVL of Arbitrum\" -> \"what is the current TVL of Arbitrum\"\n- Current: \"as I asked before, what's the value?\" (ambiguous) -> Use context to determine the specific metric being asked about`;\n\nexport const copilotProvider: Provider = {\n  get: async (runtime: AgentRuntime, message: Memory, state?: State) => {\n    // Validate configuration\n    validateConfig(DEFAULT_CONFIG);\n\n    const apiKey = runtime.getSetting(DEFAULT_CONFIG.ENV_API_KEY);\n    if (!apiKey) {\n      elizaLogger.error(\"Messari API key not found in runtime settings\");\n      return null;\n    }\n\n    const contextState = {\n      ...state,\n      currentMessage: message.content.text,\n      recentMessages: getRecentMessages(\n        state?.recentMessagesData,\n        DEFAULT_CONFIG.RECENT_MESSAGES_COUNT\n      ),\n    };\n\n    const questionContext = composeContext({\n      state: contextState,\n      template: COPILOT_QUESTION_TEMPLATE,\n    });\n\n    elizaLogger.debug(\"Generated question context\", {\n      context: questionContext,\n    });\n\n    const copilotQuestion = await generateText({\n      runtime,\n      context: questionContext,\n      modelClass: ModelClass.MEDIUM,\n    });\n\n    if (copilotQuestion === \"NONE\") {\n      elizaLogger.info(\"No research questions identified in the message\");\n      return null;\n    }\n\n    elizaLogger.info(\"Processing research question\", {\n      question: copilotQuestion,\n    });\n\n    // Check memory first\n    const memorizedResponse = await findRelevantMemory(\n      runtime,\n      message,\n      copilotQuestion,\n      DEFAULT_CONFIG.MEMORY_TTL_HOURS\n    );\n\n    if (memorizedResponse) {\n      elizaLogger.info(\"Using cached response from memory\");\n      return memorizedResponse;\n    }\n\n    // If no memory found, call API\n    const apiResponse = await callMessariAPI(\n      DEFAULT_CONFIG.API_ENDPOINT,\n      apiKey,\n      copilotQuestion\n    );\n\n    if (apiResponse) {\n      // Store successful response in memory\n      await storeMemory(runtime, message, copilotQuestion, apiResponse);\n    }\n\n    return apiResponse;\n  },\n};\n","import { elizaLogger } from \"@elizaos/core\";\nimport type { MessariAPIResponse, MessariError } from \"./types\";\n\n/**\n * Makes a request to the Messari API\n * @param apiEndpoint - The Messari API endpoint\n * @param apiKey - The Messari API key\n * @param question - The question to ask\n * @returns The API response content or null if there's an error\n */\nexport async function callMessariAPI(\n  apiEndpoint: string,\n  apiKey: string,\n  question: string\n): Promise<string | null> {\n  try {\n    const response = await fetch(apiEndpoint, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-messari-api-key\": apiKey,\n      },\n      body: JSON.stringify({\n        messages: [\n          {\n            role: \"user\",\n            content: question,\n          },\n        ],\n      }),\n    });\n\n    if (!response.ok) {\n      const responseText = await response.text();\n      const error = new Error() as MessariError;\n      error.status = response.status;\n      error.statusText = response.statusText;\n      error.responseText = responseText;\n      throw error;\n    }\n\n    const data = (await response.json()) as MessariAPIResponse;\n    const res = data.data.messages[0].content;\n    elizaLogger.debug(\"Messari API response\", {\n      response: res,\n    });\n    return res;\n  } catch (error) {\n    const err = error as MessariError;\n    elizaLogger.error(\"Error calling Messari API:\", {\n      status: err.status,\n      statusText: err.statusText,\n      responseText: err.responseText,\n      message: err.message,\n    });\n    return null;\n  }\n}\n","import type { MessariConfig } from \"./types\";\n\n/**\n * Default configuration values for the Messari provider\n */\nexport const DEFAULT_CONFIG: MessariConfig = {\n  RECENT_MESSAGES_COUNT: 5,\n  API_ENDPOINT: \"https://api.messari.io/ai/v1/chat/completions\",\n  ENV_API_KEY: \"MESSARI_API_KEY\",\n  MEMORY_TTL_HOURS: 24,\n} as const;\n\n/**\n * Validates the configuration values\n * @param config - The configuration to validate\n * @throws Error if configuration is invalid\n */\nexport function validateConfig(config: MessariConfig): void {\n  if (config.RECENT_MESSAGES_COUNT < 1) {\n    throw new Error(\"RECENT_MESSAGES_COUNT must be greater than 0\");\n  }\n  if (config.MEMORY_TTL_HOURS < 1) {\n    throw new Error(\"MEMORY_TTL_HOURS must be greater than 0\");\n  }\n  if (!config.API_ENDPOINT.startsWith(\"https://\")) {\n    throw new Error(\"API_ENDPOINT must be a secure HTTPS URL\");\n  }\n  if (!config.ENV_API_KEY) {\n    throw new Error(\"ENV_API_KEY must be specified\");\n  }\n}\n","import { AgentRuntime, elizaLogger, embed } from \"@elizaos/core\";\nimport type { Memory } from \"@elizaos/core\";\nimport type { MessariMemory } from \"./types\";\n\n/**\n * Searches for a relevant memory that might answer the question\n * @param runtime - The agent runtime\n * @param message - The current message\n * @param question - The research question to find memory for\n * @param ttlHours - How long to consider memories valid\n * @returns The memory content if found, null otherwise\n */\nexport async function findRelevantMemory(\n  runtime: AgentRuntime,\n  message: Memory,\n  question: string,\n  ttlHours: number\n): Promise<string | null> {\n  try {\n    const memories = await runtime.knowledgeManager.searchMemoriesByEmbedding(\n      await embed(runtime, question),\n      {\n        match_threshold: 0.8,\n        count: 1,\n        roomId: message.roomId,\n        unique: true,\n      }\n    );\n\n    if (memories && memories.length > 0) {\n      const memory = memories[0];\n      const age = new Date().getTime() - (memory.createdAt || 0);\n\n      if (age <= ttlHours * 60 * 60 * 1000) {\n        elizaLogger.info(\"Found relevant memory\", {\n          question,\n          memoryAge: age,\n        });\n        return memory.content.text;\n      }\n    }\n    return null;\n  } catch (error) {\n    elizaLogger.error(\"Error searching memories:\", error);\n    return null;\n  }\n}\n\n/**\n * Stores an API response in memory\n * @param runtime - The agent runtime\n * @param message - The current message\n * @param question - The original question\n * @param response - The API response to store\n */\nexport async function storeMemory(\n  runtime: AgentRuntime,\n  message: Memory,\n  question: string,\n  response: string\n): Promise<void> {\n  try {\n    const memory: MessariMemory = {\n      userId: message.userId,\n      agentId: runtime.agentId,\n      roomId: message.roomId,\n      content: {\n        text: response,\n        source: \"messari\",\n        action: question,\n      },\n      createdAt: new Date().getTime(),\n    };\n\n    await runtime.knowledgeManager.createMemory(memory, true);\n    elizaLogger.info(\"Stored response in memory\", {\n      question,\n    });\n  } catch (error) {\n    elizaLogger.error(\"Error storing memory:\", error);\n  }\n}\n\n/**\n * Extracts recent messages from state\n * @param recentMessagesData - Array of recent messages\n * @param count - Number of recent messages to include\n * @returns A string of recent messages\n */\nexport function getRecentMessages(\n  recentMessagesData: Memory[] | undefined,\n  count: number\n): string {\n  return (\n    recentMessagesData\n      ?.slice(-count)\n      .map((m) => m.content.text)\n      .join(\"\\n\") || \"\"\n  );\n}\n","export { copilotProvider } from \"./messari\";\n","import { copilotProvider } from \"./providers/messari/index.ts\";\n\nexport * as providers from \"./providers\";\n\nexport const messariPlugin = {\n  name: \"messariAiToolkit\",\n  description: \"Messari AI Toolkit\",\n  actions: [],\n  providers: [copilotProvider],\n};\n"],"mappings":"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","names":["elizaLogger","elizaLogger","elizaLogger"]}